<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>D3: Scaling the Recifes projection</title>
		<script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
		<style type="text/css">
			/* No style rules here yet */		
		</style>
	</head>
	<body>
		<div style="height:30px">
			<input type="checkbox"> Distinguish accidents by colors</input>
		</div>
		<script type="text/javascript">

			//Width and height
			var w = 900;
			var h = 500;
			var recifes_map_array = [];
			var recifes_accident_array = []
			var circlesX = []
			var circlesY = []
			var type = []
			var xOffset = 0;
			var yOffset = 0;
			var initialMousePosition  = [0,0] 
			var state = "idle";
			var scaleFactor = 1.0;
			var colors = false
			var cyclemotors = 0
			var automobiles = 0
			var bicycleandpeople = 0
			var rectangle = {
		                x       : 0,
		                y       : 0,
		                width   : 0,
		                height  : 0
		            }

		// =============== Map insertion ===============	

			//Define path generator
			var projection = d3.geoMercator()
			.translate([(w/2)-xOffset, (h/2)+yOffset])
			.center([-34.87986, -8.05596])
			.scale([100000*scaleFactor]);

			//Create SVG element
			var svg = d3.select("body")
						.append("svg")
						.attr("width", w)
						.attr("height", h);


			var g  = d3.select("svg")
						.append("g");

			//Define path generator
			var path = d3.geoPath()
				.projection(projection);

			d3.json("recifesMap.json", function(json) {
				for (elem in json.features) {
			   		recifes_map_array.push(json.features[elem]);
			    }
 
				paths = g.selectAll("path")
					.data(recifes_map_array);
			
				//Bind data and create one path per GeoJSON feature
				paths
					.enter()
					.append("path")
					.attr("d", path)
					.attr("fill", "#2a1c0e")
		});

		// =============== Accidents insertion ===============		

		//Define circle generator
		var circle = d3.geoPath().projection(projection);

		d3.json("november2014Accidents.json", function(json) {
			for (elem in json.features) {
				recifes_accident_array.push(json.features[elem]);
		    }

			circles = g.selectAll("circle")
				.data(recifes_accident_array);
	    
		    //Create circles
		    circles
			.enter()
			.append("circle")
			.attr("fill", '#CD853F')
			.attr("cx", function(accident) {
			    return projection([accident.properties.longitude, accident.properties.latitude])[0];
			})
			.attr("cy", function(accident) {
		        return projection([accident.properties.longitude, accident.properties.latitude])[1];
			})
			.attr('r', 1)

			for (i in recifes_accident_array){
				type.push(recifes_accident_array[i].properties.tipo);
			}	
		});

		// =============== Pan & Zoom insertion ===============		
		d3.select("input")
		.on("click", function(){
			colors = !colors;
			renderDataset()
		})


		d3.select("svg")
		.on("contextmenu", function() {
			state = "select"
			d3.event.stopPropagation();
    		d3.event.preventDefault();
		})
		.on("mousedown",function(eventData){	    
		    var p = d3.mouse( this);
		    initialMousePosition = p;
		    if (d3.event.which === 3) {
		    	state = "select"
				svg.append( "rect")
			        .attr("rx", 6)
			        .attr("ry", 6)
			        .attr("x", p[0])
			        .attr("y", p[1])
			        .attr("width", 0)
			        .attr("height", 0)
			        .attr("stroke", 'gray')
			        .attr("fill", 'transparent')
			        .attr('stroke-width', '1px')
			        .attr('stroke-dasharray', '4px')
			        .attr('stroke-opacity', '0.5')

		    } else {
		    	state = "pan";
		    }
		    d3.event.stopPropagation();
			d3.event.preventDefault();
		})
		.on("mousemove",function(d){
		    if(state === "pan"){
		    	// console.log("mousemove - state: ", state)
		    	var p = d3.mouse( this),
	            move = {
	                x : p[0] - initialMousePosition[0],
	                y : p[1] - initialMousePosition[1]
	            };
				xOffset -= (move.x);
				yOffset += (move.y);
			    initialMousePosition = p;    
				renderDataset();
				d3.event.stopPropagation();
				d3.event.preventDefault();
		    }

			if(state === "select"){
				var s = svg.select( "rect");
			    if( !s.empty()) {
			        var p = d3.mouse( this),
		            d = {
		                x       : parseInt( s.attr( "x"), 10),
		                y       : parseInt( s.attr( "y"), 10),
		                width   : parseInt( s.attr( "width"), 10),
		                height  : parseInt( s.attr( "height"), 10)
		            },
		            move = {
		                x : p[0] - d.x,
		                y : p[1] - d.y
		            };

			        if( move.x < 1 || (move.x*2<d.width)) {
			            d.x = p[0];
			            d.width -= move.x;
			        } else {
			            d.width = move.x;       
			        }

			        if( move.y < 1 || (move.y*2<d.height)) {
			            d.y = p[1];
			            d.height -= move.y;
			        } else {
			            d.height = move.y;       
			        }
			       
			        s
			        .attr("x", d.x)
			        .attr("y", d.y)
			        .attr("width", d.width)
			        .attr("height", d.height);
			        rectangle = d;
				} 
			}
		})
		.on("mouseup",function(d){
		    state = "idle";
		    svg.select("rect").remove();
		    renderDataset();
			
	    	accidentsSelected()

		    d3.event.stopPropagation();
			d3.event.preventDefault();
		})
		.on("wheel.zoom",function(d){
	        if (d3.event.wheelDeltaY <= 0)
	        	scaleFactor *= 0.9;
	        else
		        scaleFactor *= 1.1;
		    renderDataset();
		    d3.event.stopPropagation();
	        d3.event.preventDefault();  
	    });

			// =============== Update paths and circles ===============	
			function renderDataset(){	

				var projection = d3.geoMercator()
				.translate([w/2-xOffset, h/2+ yOffset])
				.center([-34.87986,-8.05596])
				.scale(100000*scaleFactor);

				path = d3.geoPath()
				.projection(projection)

				//Remove circles that are not needed
			    g.selectAll("path")
				.data(recifes_map_array)
				.exit()
				.remove();

				// Updates paths
				g.selectAll("path")
				.data(recifes_map_array)
				.attr("d", path)


				circles = g.selectAll("circle")
				.data(recifes_accident_array)

				//Remove circles that are not needed
			    circles
				.exit()
				.remove();

				circlesX = []
				circlesY = []

				// Updates circles
				circles
				.attr("fill", '#CD853F')
				.attr("cx", function(accident) {
				    x = projection([accident.properties.longitude, accident.properties.latitude])[0]
				    circlesX.push(x)
				    return x;
				})
				.attr("cy", function(accident) {
			        y = projection([accident.properties.longitude, accident.properties.latitude])[1];
			        circlesY.push(y);
			        return y;
				})
				.attr('r', 1*scaleFactor)

				if (colors){
					g.selectAll("circle")
					.attr("fill",
                		function(d){
			            	type = d.properties.tipo
			            	if(type == "Moto e Ciclomotor")
			                	return "#feb24c";
			                else if (type == "Ciclistas e pedestre")
			                	return "#f03b20";
			                else if (type == "Automóveis e outros")
			                	return "#ffeda0";
			                else 
			                	return "#ffffff";
					})
				}
			}

			function accidentsSelected(){
				cyclemotors = 0;
				bicycleandpeople = 0;
				automobiles = 0

				rect_x_min = rectangle.x;
		    	rect_x_max = rectangle.x + rectangle.width;
		    	rect_y_min = rectangle.y;
		    	rect_y_max = rectangle.y + rectangle.height;

				for (i = 0; i < circlesX.length; i++) {
					if (circlesX[i] >= rect_x_min &&
					    circlesX[i] <= rect_x_max &&
					    circlesY[i] >= rect_y_min &&
					    circlesY[i] <= rect_y_max ){
					      	if(type[i] == "Moto e Ciclomotor")
			                	cyclemotors += 1;
			                else if (type[i] == "Ciclistas e pedestre")
			                	bicycleandpeople += 1;
			                else if (type[i] == "Automóveis e outros")
			                	return automobiles +=1;
				    }
				}

				// Em alguns momentos o valor não é impresso, mas se essa linha for executadano console obtemos o resultado.

				console.log("Automóveis e outros: ", automobiles, "\nCiclistas e pedestre: ", bicycleandpeople, "\nMoto e Ciclomotor", cyclemotors)
			}
		</script>
	</body>
</html>
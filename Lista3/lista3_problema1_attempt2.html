<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>D3: Scaling the Recifes projection</title>
		<script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
		<style type="text/css">
			/* No style rules here yet */		
		</style>
	</head>
	<body>
		<script type="text/javascript">

			//Width and height
			var w = 900;
			var h = 500;
			var recifes_map_array = [];
			var recifes_accident_array = []
			var xOffset = 0;
			var yOffset = 0;
			var initialMousePosition  = [0,0] 
			var state = "idle";
			var scaleFactor = 1.0;

		// =============== Map insertion ===============	

			//Define path generator
			var projection = d3.geoMercator()
			.translate([(w/2)-xOffset, (h/2)+yOffset])
			.center([-34.87986, -8.05596])
			.scale([100000*scaleFactor]);

			//Create SVG element
			var svg = d3.select("body")
						.append("svg")
						.attr("width", w)
						.attr("height", h);

			var g  = d3.select("svg")
						.append("g");

			//Define path generator
			var path = d3.geoPath()
				.projection(projection);

			d3.json("recifesMap.json", function(json) {
				for (elem in json.features) {
			   		recifes_map_array.push(json.features[elem]);
			    }
 
				paths = g.selectAll("path")
					.data(recifes_map_array);
			
				//Bind data and create one path per GeoJSON feature
				g.selectAll("path")
					.data(recifes_map_array)
					.enter()
					.append("path")
					.attr("d", path)
					.attr("fill", "#2a1c0e")
		});

		// =============== Accidents insertion ===============		

		//Define circle generator
		var circle = d3.geoPath().projection(projection);

		d3.json("november2014Accidents.json", function(json) {
			for (elem in json.features) {
				recifes_accident_array.push(json.features[elem]);
		    }

			circleSelection = g.selectAll("circle")
				.data(recifes_accident_array);
	    
		    //Create circles
		    circleSelection
			.enter()
			.append("circle")
			.attr("fill", '#CD853F')
			.attr("cx", function(accident) {
			    return projection([accident.properties.longitude, accident.properties.latitude])[0];
			})
			.attr("cy", function(accident) {
		        return projection([accident.properties.longitude, accident.properties.latitude])[1];
			})
			.attr('r', 1)
		});

		// =============== Pan & Zoom insertion ===============		

			d3.select("g")
			.on("mousedown",function(d){	    
				    var p = d3.mouse( this);
				    initialMousePosition = p;
				    console.log(p)
				    state = "pan";
				    d3.event.stopPropagation();
					d3.event.preventDefault();
				})
				.on("mousemove",function(d){
				    if(state === "pan"){
				    var p = d3.mouse( this),
			            move = {
			                x : p[0] - initialMousePosition[0],
			                y : p[1] - initialMousePosition[1]
			            };
					xOffset -= (move.x);
					yOffset += (move.y);
				    initialMousePosition = p;    
					renderDataset();
					d3.event.stopPropagation();
					d3.event.preventDefault();
				    }})
				.on("mouseup",function(d){	
				    state = "idle";
				    renderDataset();
				    d3.event.stopPropagation();
					d3.event.preventDefault();
				})
				.on("wheel.zoom",function(d){
			        if (d3.event.wheelDeltaY <= 0)
			        	scaleFactor *= 1.1;
			        else
				        scaleFactor *= 0.9;
				    console.log(scaleFactor)
				    renderDataset();
				    d3.event.stopPropagation();
			        d3.event.preventDefault();  
			    });

			// =============== Update paths and circles ===============	
			function renderDataset(){	

				var projection = d3.geoMercator()
				.translate([w/2-xOffset, h/2+ yOffset])
				.center([-34.87986,-8.05596])
				.scale(100000*scaleFactor);

				path = d3.geoPath()
				.projection(projection)

				//Remove circles that are not needed
			    g.selectAll("path")
				.data(recifes_map_array)
				.exit()
				.remove();

				// Updates paths
				g.selectAll("path")
				.data(recifes_map_array)
				.attr("d", path)

				//Remove circles that are not needed
			    g.selectAll("circle")
				.data(recifes_accident_array)
				.exit()
				.remove();

				// Updates circles
				g.selectAll("circle")
				.data(recifes_accident_array)
				.attr("fill", '#CD853F')
				.attr("cx", function(accident) {
				    return projection([accident.properties.longitude, accident.properties.latitude])[0];
				})
				.attr("cy", function(accident) {
			        return projection([accident.properties.longitude, accident.properties.latitude])[1];
				})
				.attr('r', 1)
			}
		</script>
	</body>
</html>
